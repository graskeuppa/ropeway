use std::env;
use std::io::{BufRead, BufReader, Write};
use std::process::{Command, Stdio};

fn main() -> anyhow::Result<()> {
    let args: Vec<String> = env::args().skip(1).collect();

    if args.is_empty() {
        eprintln!("Command expected. Make sure to include it after \"cargo run\"");
        std::process::exit(1);
    }

    let command_str = args.join(" ");

    // Path to the .jar generated by Gradle
    let jar_path = std::path::PathBuf::from(std::env::var("HOME")?)
        .join("ropeway/testing/backend-java/app/build/libs/app-all.jar");

    // Starts the Java backend as a process
    let mut child = Command::new("java")
        .arg("-jar")
        .arg(jar_path)
        .current_dir(std::path::PathBuf::from(std::env::var("HOME")?).join("ropeway/testing"))
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect("Unable to launch backend, yo!");

    // Access to sdtin and stdout from child process
    let stdin = child.stdin.as_mut().expect("Couldn't access stdin, yo!");
    let stdout = child.stdout.as_mut().expect("Couldn't access stdout, yo!");
    let mut reader = BufReader::new(stdout);

    // Writes the command to the backend
    //writeln!(stdin, "MAKE_MOVE 2025-05-16 120 POK CSH")?;
    writeln!(stdin, "{}", command_str)?;

    // Reads the backend's answer
    let mut response = String::new();
    reader.read_line(&mut response)?;

    // Print the answer to the console
    println!("Backend's answer:\n{}", response.trim());
    Ok(())
}
